# 相关条目排序稳定性修复

## 问题描述

在使用 `tools/retag_and_related.py` 脚本时,发现每次运行都会导致大量词条的"相关条目"部分发生无意义更新,检查 Git diff 后发现只是相关条目的排序位置变动,而不是内容变化。

## 问题原因

### 根本原因: 浮点数排序不稳定

在 `compute_related()` 函数中,相关条目按以下规则排序:

```python
results.sort(
    key=lambda item: (
        -item[1],  # 按分数降序
        english_title_key(all_posts[item[0]]),  # 按英文标题
    )
)
```

**问题所在:**

1.**浮点数精度问题**: 相似度分数是浮点数计算结果,可能存在微小的精度差异
2.**非确定性**: 当两个条目分数非常接近(如 0.3500000001 vs 0.3499999999)时,排序结果可能不稳定
3.**次要排序不足**: 即使有 `english_title_key` 作为次要排序键,但当分数有微小差异时不会生效

### 影响

- 每次运行脚本都会产生大量无意义的 Git diff
- 难以追踪真正有意义的内容变更
- 增加 code review 负担
- 污染 Git 历史

## 解决方案

### 修复代码

在 `tools/retag_and_related.py` 第 664-670 行,修改排序逻辑:

```python
results.sort(
    key=lambda item: (
        -round(item[1], 6),  # 将分数四舍五入到6位小数,避免浮点数微小差异
        english_title_key(all_posts[item[0]]),  # 按英文标题排序
        str(item[0])  # 如果分数和标题都相同,按路径排序确保完全稳定
    )
)
```

### 改进点

1.**分数归一化**: `round(item[1], 6)` 将分数四舍五入到 6 位小数

   - 消除浮点数微小差异
   - 保留足够精度(0.000001)用于区分真正的分数差异

2.**英文标题次排序**: 当分数相同时,按英文标题字母顺序排序

   - 提供人类可读的稳定排序
   - 符合用户预期

3.**路径终排序**: 当分数和标题都相同时,按文件路径排序

   - 提供最终的稳定性保证
   - 确保完全确定性的排序结果

## 测试验证

### 测试脚本

创建了 `tools/test_retag_stability.py` 用于验证排序稳定性:

```bash
python tools/test_retag_stability.py
```

### 测试结果

```text
测试 retag_and_related.py 排序稳定性...
============================================================

第 1 次运行...
  处理了 10 个词条

第 2 次运行...
  处理了 10 个词条

第 3 次运行...
  处理了 10 个词条

============================================================
比较结果:
============================================================

============================================================
稳定的词条: 10
不稳定的词条: 0
============================================================

[OK] 测试通过! 所有词条的相关条目排序都是稳定的。
```

**结论**: ✅ 修复成功,所有词条的相关条目排序现在完全稳定

## 使用建议

### 重新运行脚本

修复后,建议执行一次完整的标签重建:

```bash

# 预览模式查看变更

python tools/retag_and_related.py --dry-run

# 确认后执行

python tools/retag_and_related.py
```

### 预期效果

- 第一次运行修复后的脚本,可能会有较多变更(调整到稳定排序)
- 之后再次运行,应该不会产生任何排序相关的变更
- 只有当词条内容、标签或标题真正改变时,才会更新相关条目

## 技术细节

### 分数计算公式

```python
score = 0.55 * jaccard + 0.30 * cos
if cur_path.parent == other_path.parent:
    score += 0.15
```

-**Jaccard 相似度**(55%): 基于标签重叠
-**余弦相似度**(30%): 基于内容词频
-**同目录加成**(15%): 同一目录的词条

### 为什么是 6 位小数?

-**足够精度**: 0.000001 的差异足以区分真正不同的相关度
-**避免过度敏感**: 不会因为极微小的计算差异导致排序变化
-**性能考虑**: round() 操作非常快,不影响性能

## 相关文件

- `tools/retag_and_related.py` - 主脚本(已修复)
- `tools/test_retag_stability.py` - 稳定性测试脚本
- `docs/tools/README.md` - 工具使用说明

## 更新日志

-**2025-10-05**: 修复相关条目排序稳定性问题
-**2025-10-05**: 添加稳定性测试脚本

---

**维护者**: Plurality Wiki Team
**最后更新**: 2025-10-05
